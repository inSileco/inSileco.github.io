---
title: Inferring transition probabilities with R, Quebec forest as an example
author: [kevin]
date: 2024-06-25
tags: [Markov chain, R]
rpkgs: [msm, INLA, INLAjoint]
tweet: "Inferring transition probabilities with R"
draft: true
review: false
rbloggers: false
estime: 20
bibliography: "`r path_ref_bib`"
csl: "`r path_ref_csl`"
tldr: |
    Inferring transition probabilities with R. Using msm package and Cox model with INLA.
output:
  blogdown::html_page:
    dev: svglite
---


## Context and problem

### Quebec forest and global change

In Canada, forests are a significant economic asset. [^refw1]. 
In Quebec, more specifically, forestry represents 6,4 G$ of GDP.
Forests are directly impacted via forestry, land-use change, or indirectly by climate change. 


[^refw1]: https://ressources-naturelles.canada.ca/nos-ressources-naturelles/forets/letat-forets-canada-rapport-annuel/lindustrie-forestiere-contribue/16518

https://ressources-naturelles.canada.ca/sites/nrcan/files/forest/sof2023/NRCAN_SofForest_Annual_2023_FR_Vf.pdf

> Les données de 2023 confirment la place centrale qu’occupe le secteur forestier dans l’économie québécoise :

> * PIB de 6,4 G$ (soit 1,5 % de l’activité économique globale du Québec);

> Près de 2 000 établissements emploient plus de 57 000 travailleurs et travailleuses;

> Environ 21,8 G$ en livraisons manufacturières (nationales et internationales).


Modelling forest is therefore a central challenge. There are various approaches. To understand, the evolution of community at large scale under climate change, one approach is to consider forest plots as units in a given state and strive to model the transition dynamics among these states. 

Along the longitudinal gradient, there is a clear can be simplified as 3 states: Boreal (B), Temperate (T), Pioneer (P). Example found in @Brice_2020 There is one more, here we could consider that were Temperate and Boreal co-occur is Mixed but do not explicit to reduce the number of state to three.  

![Three state model: Temperate, Boreal and Pioneer species.](img/multistates.svg){.center width=70%}




### Markov chains 

#### Definition and considerations

A major tool to model transitions between a set of states is Markov chain. As explained on Wikipedia:

> A Markov chain or Markov process is a stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event (Wikipedia https://en.wikipedia.org/wiki/Markov_chain).


There are numerous course available on line to learn more about Markov chains (e.g. on the [MIT](https://ocw.mit.edu/courses/6-041-probabilistic-systems-analysis-and-applied-probability-fall-2010/resources/lecture-16-markov-chains-i/) website or on the website of [University of Cambridge](https://www.statslab.cam.ac.uk/~rrw1/markov/index.html)). Here we do not aim at going at exploring the mathematical properties of Markov chains, though we will mention key properties and important results when required. 
We further note that Markov chains tool to build theoretical model. One example is the revisit of the classical model of biogeography 
[@Cazelles_2016] whereMarkov chains where used to explore the role of trophic interactions. There is also a in depth derivation of the chains that can be of use: https://kevcaz.insileco.io/biogeonet/articles/Cazelles_2016_SI.html.


#### Continuous versus Discrete time Markov chain

It may be easier to understand think about Markov chain using discrete time. For instance, in our case, it may be easier to think about the probability that a plot dominated by boreal species could switch to a state where the dominating species are temperature. With an increase of a few degree we may get the estimate for a period, say 20 years that this happens. 
We can then try to convert that for a year, then for a day. This is how the question of the value of the instant rate arise, this is how we jump from dis


TODO: show the math. 







## Generating a mock datasets 

Here we will start be generating a theoretical model of our system to show how Markov chains work. We will then use our Markov chain to generate a mock dataset that describes transition. The goal is to generate a dataset that resembles to the real one used in @Brice_2020.



### Generating states dynamics using a discrete Markov chain

At time t (here $t \in \mathbb{N}$) $\mathbb{P}_{t}(B, P, D)$ describes the vector of probabilities of the three states. For instance, if $P_{0}(B, P, D) = (0.5, 0.1, 0.4)$ means probability that 0.5 in state Boreal (community of tree species is classified as boreal because species composition), 0.1 in state P and 0.4 in Temperate.

$$\mathbb{P}_{t+1}(B, P, D) = \mathbf{B}\mathbb{P}_{t}(B, P, D)$$

Here $P_{t+1}(B, P, D)$ is a column vector but it is also frequent to use the row vector (important to keep this is mind).

Once defined, the Markow chain can be used to dynamic. 

$$\mathbb{P}_{t+2}(B, P, D) = \mathbf{B}\mathbb{P}_{t+1}(B, P, D) = \mathbf{B}^2 \mathbb{P}_{t}(B, P, D)$$

By induction:

$$\mathbb{P}_{t+n}(B, P, D) = \mathbf{B}^n\mathbb{P}_{t}(B, P, D)$$

And because of Markov property $t$ does not matter. One important result for [ergodic Markov chains](https://en.wikipedia.org/wiki/Markov_chain#Ergodicity) is that the proportioned is given by the eigen vector corresponding to the eigen value 1.

Below we create functions to run the dynamics. Note that a column vector is used for the state distribution and that it is also common to use the row vector, it just the eigen vector to be used to assess the distribution. 

```{r mc}
# This function creates the Markov matrix as we have 3 states it is a 3x3 matrix
# p_ij means transition probability from state i to state j
gen_mc <- function(p_BP, p_BT, p_PB, p_PT, p_TP, p_TB) {
  check_pair(p_BP, p_BT) # helper function see below
  check_pair(p_PB, p_PT)
  check_pair(p_TP, p_TB)
  #
  cbind(
    c(1 - p_BP - p_BT, p_BP, p_BT),
    c(p_PB, 1 - p_PB - p_PT, p_PT),
    c(p_TB, p_TP, 1 - p_TB - p_TP)
  )
}

# helper function: check that values are probabilities
check_pair <- function(x, y) {
  stopifnot(x >= 0)
  stopifnot(x <= 1)
  stopifnot(y >= 0)
  stopifnot(y <= 1)
  stopifnot(x + y <= 1)
}

# the function below runs the Markov chain and stored results in a matrix that # has many columns as there are time steps
run_mc <- function(start, M, n = 1) {
  out <- start |> as.matrix()
  for (i in seq_len(n)) {
    out <- cbind(out, M %*% out[, i])
  }
  out
}

# Function to obtaine the equilibrium using the eigen vector
get_eq <- function(M) {
  tmp <- eigen(M)$vectors[, 1] / sum(eigen(M)$vectors[, 1])
  # if some other eigen are imaginary all eigen vector will be imaginary so we 
  # use the Real part after checking that it is actually a purely real number 
  # which is what we expect 
  stopifnot(all(Im(tmp) == 0))
  Re(tmp)
}
```

We now use the functions below to generate two dynamics, one that starts with 
a boreal state and we assess what is distribution probabilities over the next 25 years. The second dynamics is similar but start we a temperate state.

```{r mc2, fig.width = 10}
# Generate the matrix M describing the Markov Chain
M <- gen_mc(0.1, 0.2, 0.2, 0.2, 0.05, 0.15)
# Run it for 25 years
res <- run_mc(c(1, 0, 0), M, 25)
res2 <- run_mc(c(0, 0, 1), M, 25)
# Get the proportion at equilibrium
v_eq <- get_eq(M)

# Create the plot
par(las = 1, mfrow = c(1, 2))
## Color palette
pal <- c("#87cdde", "#8d5fd3", "#ff2a7f")
plot(c(0, 25), c(0, 1), type = "n", xlab = "Time", ylab = "Probability")
## Add dynamics
for (i in 1:3) {
  lines(0:25, res[i, ], col = pal[i], lwd = 4)
}
## Add proportion at equilibrium as point
for (i in 1:3) {
  points(25, v_eq[i], col = pal[i], cex = 3, pch = 19)
}
## Second plot 
pal <- c("#87cdde", "#8d5fd3", "#ff2a7f")
plot(c(0, 25), c(0, 1), type = "n", xlab = "Time", ylab = "Probability")
for (i in 1:3) {
  lines(0:25, res2[i, ], col = pal[i], lwd = 4)
}
for (i in 1:3) {
  points(25, v_eq[i], col = pal[i], cex = 3, pch = 19)
}
legend("topright", legend = c("B", "P", "T"), col = pal, lty = 1, lwd = 2, 
  bty  ="n")
```



### Influence of the temperature of the transition probabilities

We now will introduce the influence of the temperature on the dynamics. 
Use this so that transition probabilities change with temperate. Here it is annual temperature and order of magnitude works for Quebec (-10°C and 10°C).


```{r trans_temp, fig.width=9}
## We will use this function to model the impact of the dynamic 
## logit and its inverse comes with R in the 'stats' package but for good 
## reseaon they are named differently, see 
## https://ro-che.info/articles/2018-08-11-logit-logistic-r
logit <- stats::qlogis
inv_logit <- stats::plogis

## Sequence of the 
s_temp <- seq(-10, 10, 0.1)

# Transition probabilities as functions of the temperature
p_BT_temp <- function(temp) 0.1 * inv_logit(temp * 0.5 - 2)
p_TB_temp <- function(temp) 0.1 * (1 - inv_logit(temp * 0.5 + 2))
p_PT_temp <- function(temp) 0.5 * inv_logit(temp * 0.5)
p_PB_temp <- function(temp) 0.5 * (1 - inv_logit(temp * 0.5))

par(las = 1, mfrow = c(1, 2))

plot(range(s_temp), c(0, 0.1), type = "n", 
  main = "Temperate-Boreal transitions", xlab = "Temperatue", 
  ylab = "Transtion probabilities")
lines(s_temp, p_BT_temp(s_temp), lty = 1, lwd = 2)
lines(s_temp, p_TB_temp(s_temp), lty = 2, lwd = 2)
legend("right", c("p_BT", "p_TB"), bty = "n", lwd = 2, lty = c(1, 2))

plot(range(s_temp), c(0, 0.5), type = "n", main = "Pioneer transtions", 
  xlab = "Temperatue", ylab = "Transtion probabilities")
lines(s_temp, p_PT_temp(s_temp), lty = 1, lwd = 2)
lines(s_temp, p_PB_temp(s_temp), lty = 2, lwd = 2)
legend("right", c("p_PT", "p_PB"), bty = "n", lwd = 2, lty = c(1, 2))
```


Using previous code, we can generate the equilibrium along the gradient.

TODO: use the transient dynamics, not the equilibrium. 


```{r prop_state_temp, fig.width=8}
gen_mc_temp <- function(temp) {
  gen_mc(
    p_BP = 0.1,
    p_BT = p_BT_temp(temp), 
    p_PB = p_PB_temp(temp), 
    p_PT = p_PT_temp(temp), 
    p_TP = 0.05,
    p_TB = p_TB_temp(temp)
  )
}

grad_eq <- function(v_temp) {
  out <- list()
  for (i in seq(v_temp)) {
    out[[i]] <- gen_mc_temp(v_temp[i]) |> get_eq()
  }
  do.call(cbind, out)
}


s_temp <- seq(-10, 10, 0.1)
res <- grad_eq(s_temp)

par(las = 1)
plot(range(s_temp), c(0, 1), type = "n", xlab = "Temperature", ylab = "Probabilities")
for (i in 1:3) {
    lines(s_temp, res[i, ], col = pal[i], lwd = 4)
}
```



### Generating data set using equilibrium

We need to element, one way to generate the state of based on temperature and one function one temperature mode.

```{r sample_state}
sample_states <- function(temp) {
  if (length(temp) > 1) {
    lapply(temp, sample_states) |> unlist()
  } else {
    eq <- gen_mc_temp(temp) |> get_eq()
    c("B", "P", "T")[which(runif(1) <= cumsum(eq))[1L]]
  }
}
```

A simple function that gives us temperature over latitude and time. All made up.

```{r mod_temp}
# Create a temperature gradient grid
mod_temp <- function(time, latitude) {
  (time - 1960) * 0.02 + (55 - latitude) + rnorm(1) * 2
}
```

```{r mockdata, cache = TRUE}
gen_data_plot <- function(n) {
  out <- list()
  for (i in seq_len(n)) {
    out[[i]] <- data.frame(
      plot_id = i,
      latitude = rep(runif(1, 45, 65), 3),
      time = 1960.0 + runif(3, 10, 20) |> cumsum()
    )
    out[[i]]$temperature <- mod_temp(out[[i]]$time, out[[i]]$latitude)
    out[[i]]$state <- sample_states(out[[i]]$temperature)
  }
  out |>
    do.call(what = rbind)
}

set.seed(777)
mock_data <- gen_data_plot(15000)
head(mock_data)
```





## Inference with package `msm`

The package [`msm`](https://CRAN.R-project.org/package=msm)
(Multi-State Markov and Hidden Markov Models in Continuous Time) created and maintained by [Christopher Jackson](https://github.com/chjackson) was designed to fit and predict from multi-state models for intermittently observed data. There is a practical course with material available o line https://chjackson.github.io/msm/msmcourse/. This will use likelihood inference.

```{r msm1}
library(msm)
# msm required numbers for state 
# B is 1, P is 2, T is 3
mock_data$state2 <- as.factor(mock_data$state) |> 
  as.numeric()

statetable.msm(state, plot_id, data = mock_data)
```

Here all our states communicates.

```{r msm2}
Q <- matrix(1, 3, 3)
```

With no covariates. 

```{r msm3, cache = TRUE}
res1 <- msm(state2 ~ time,
  subject = plot_id,
  data = mock_data,
  qmatrix = Q,
  gen.inits = TRUE,
  control = list(maxit = 1000, fnscale = 30000, trace = 1, reltol = 1e-16)
)
pmatrix.msm(res1, t = 1)
```

> It is often worthwhile to normalize the optimization using
> ‘control=list(fnscale = a)’, where ‘a’ is the a number of the
> order of magnitude of the -2 log likelihood.


Note that `list(fnscale = 5000)` is required to avoid numerical overflow in the 
likelihood estimation.

>  Any diagonal entry of ‘qmatrix’ is
          ignored, as it is constrained to be equal to minus the sum of
          the rest of the row.

Temperate as covariates:

```{r msm4, cache = TRUE}
res2 <- msm(state2 ~ time,
  subject = plot_id,
  data = mock_data,
  qmatrix = Q,
  gen.inits = TRUE,
  covariates = list(
    "2-1" = ~temperature,
    "2-3" = ~temperature,
    "3-1" = ~temperature,
    "1-3" = ~temperature
  ),
  obstype = 1,
  control = list(maxit = 1000, fnscale = 10000, trace = 1, reltol = 1e-16)
)
```

Goodness fit 

```{r msm5}
res1
res2
```


Predictions

```{r msm6, fig.width = 9}
res_eq <- res_temp <- res_rate <- list()
for (i in seq(s_temp)) {
  res_temp[[i]] <- pmatrix.msm(res2, t = 1, covariates = list(temperature = s_temp[i]))
  res_rate[[i]] <- qmatrix.msm(res2, covariates = list(temperature = s_temp[i]))
  res_eq[[i]] <- t(res_temp[[i]]) |> get_eq()
}

par(las = 1, mfrow = c(1, 2))

plot(range(s_temp), c(0, 1), type = "n", xlab = "Temperature", ylab = "Transtion probabilities")
lines(s_temp, lapply(res_temp, \(x) x[1, 3]) |> unlist())
lines(s_temp, lapply(res_temp, \(x) x[3, 1]) |> unlist(), lty = 2)
legend("right", c("p_BT", "p_TB"), bty = "n", lwd = 2, lty = c(1, 2))

plot(range(s_temp), c(0, 0.5), type = "n", xlab = "Temperature", ylab = "Transtion probabilities")
lines(s_temp, lapply(res_temp, \(x) x[2, 3]) |> unlist())
lines(s_temp, lapply(res_temp, \(x) x[2, 1]) |> unlist(), lty = 2)
legend("right", c("p_PT", "p_PB"), bty = "n", lwd = 2, lty = c(1, 2))
```

```{r qmat}
par(las = 1, mfrow = c(1, 2))

plot(range(s_temp), c(0, 20), type = "n", xlab = "Temperature", ylab = "Transtion probabilities")
lines(s_temp, lapply(res_rate, \(x) x[1, 3])  |> lapply(\(x) x[1]) |> unlist())
lines(s_temp, lapply(res_rate, \(x) x[3, 1])  |> lapply(\(x) x[1]) |> unlist(), lty = 2)
legend("right", c("p_BT", "p_TB"), bty = "n", lwd = 2, lty = c(1, 2))

plot(range(s_temp), c(0, 0.5), type = "n", xlab = "Temperature", ylab = "Transtion probabilities")
lines(s_temp, lapply(res_rate, \(x) x[2, 3]) |> lapply(\(x) x[1]) |> unlist())
lines(s_temp, lapply(res_rate, \(x) x[2, 1]) |> lapply(\(x) x[1]) |> unlist(), lty = 2)
legend("right", c("p_PT", "p_PB"), bty = "n", lwd = 2, lty = c(1, 2))
```


```{r msm7, fig.width = 9}
resf <- res_eq |> do.call(what = cbind)
par(las = 1)

plot(range(s_temp), c(0, 1), type = "n", xlab = "Temperature", ylab = "Probability")
## Add dynamics
for (i in 1:3) {
  lines(s_temp, resf[i, ], col = pal[i], lwd = 4)
}
```


Example found in @Brice_2020 also see the post [Multistate Models for Medical Applications](https://rviews.rstudio.com/2023/04/19/multistate-models-for-medical-applications/) by Joseph Rickert.






## Inference via Cox model and the `INLA` package


### Survival models


## Link with survival function 

Link with Survival 

$$1 - F(t)$$

https://en.wikipedia.org/wiki/Survival_function

https://en.wikipedia.org/wiki/Survival_analysis

https://www.precision-analytics.ca/articles/a-gentle-inla-tutorial/


Hazard function 

Install inla using a Cox model 

https://becarioprecario.bitbucket.io/inla-gitbook/ch-survival.html

https://www.r-inla.org/download-install



A second option is to model every transition probability using survival function. In our case we will have 6 transition probabilities and therefore 6 hazard function to be modelled. There are various packages to do `survival` 

Over the last decade, INLA has become a popular alternative. Integrated Nested Laplace Approximation to do approximate Bayesian inference for latent Gaussian models (LGMs). Bayesian additive models with a structured additive predictor (1); namely those which assign a Gaussian prior. 

Survival model with INLA https://becarioprecario.bitbucket.io/inla-gitbook/ch-survival.htm. So now instead of the probability of an event to happen, we model the time.


INLA is not on CRAN so it may be trickier to use.

```R
install.packages("INLA", repos = c(getOption("repos"), INLA = "https://inla.r-inla-download.org/R/stable"), dep = TRUE)
```



http://www.r-inla.or
https://onlinelibrary.wiley.com/doi/epdf/10.1002/sim.10160



## References

<div id="refs"></div>


```{R sessionInfo, child = path_session_info}
```


