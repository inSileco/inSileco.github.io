---
title: "Generating empty data frames and row binding a list of data frames whose column names partially match"
author: [kevin]
date: 2019-02-03
tags: [R, data frame, data frames generation, row binding]
rpkgs: [inSilecoMisc]
draft: false
tweet: "Online ecology - Individual species description"
output:
  rmarkdown::html_page:
    toc: true
    fig_width: 3
    dev: svg
---


![](https://img.shields.io/badge/inSileco-UnderReview-ffdd55.svg)


Creating a data frame is fairly simple but when you need to [create a large empty data frame with columns that have different classes](https://stackoverflow.com/questions/10689055/create-an-empty-data-frame) it takes several command lines. A few days ago, I decided to write a function to simplify this operation and I came to realize that such a function would actually be very useful to ease the row binding of data frames whose column names partially match. How so? This post is meant to answer this question!


## inSilecoMisc

First of all, the functions I am using in this post are available in  [inSilecoMisc](http://insileco.github.io/inSilecoMisc/) which is an R package where we gathered our miscellaneous functions we deem worth sharing on GitHub. So the first step to reproduce the examples below is to install `inSilecoMisc` which is straightforward with the [devtools](https://cran.r-project.org/web/packages/devtools/index.html package) :

```r
library(devtools)
install_github("inSileco/inSilecoMisc")
```

Then, load it:

```{r}
library(inSilecoMisc)
```

In this post, I'll exemplify how to use `dfTemplate()` and `dfTemplateMatch()` but if you are interested in other functions in the packages, [check out the tour vignette](http://insileco.github.io/inSilecoMisc/articles/overview.html).



## Generating empty data frames efficiently

Let's start with `dfTemplate()` that creates a data frame with a specific number of columns.

```{r}
df1 <- dfTemplate(cols = 2)
df1
class(df1)
```

By default, the data frame created has only 1 row and the columns are filled out with `NA`. This can readily be changed using arguments `nrows` and `fill`.


```{r}
df2 <- dfTemplate(2, nrows = 4, fill = 0)
df2
df3 <- dfTemplate(cols = 2, nrows = 3, fill = "")
df3
```

Columns classes are determined by `fill`:

```{r, results = "hold"}
class(df1[,1])
class(df2[,1])
class(df3[,1])
```

And `col_classes` is used to changed these classes:

```{r, results = "hold"}
df4 <- dfTemplate(cols = 2, col_classes = "character")
class(df4[, 1])
class(df4[, 2])
```

Arguments `fill` and `col_classes` can be vectors that specify content and class
for every columns:

```{r, results = "hold"}
df5 <- dfTemplate(2, 5, col_classes = c("character", "numeric"), fill = c("", 5))
df5
class(df5[, 1])
class(df5[, 2])
```

Another useful feature of `dfTemplate()` is that column names of the data frame to be created can be passed as first argument (`cols`) :

```{r}
df5 <- dfTemplate(c("category", "value"))
```

So, now you are able to create custom data frames with a set of column names!

```{r}
nms <- replicate(10, paste(sample(LETTERS, 6, TRUE), collapse = ""))
nms
df6 <- dfTemplate(nms, 10, fill = c(NA, 0), col_classes =c("character", "numeric"))
df6
```



## Row bindings of a list of data frames whose column names partially match

Before I go through this section, I would like to mention two ways of doing row binding for data frame that have a different set of columns: [`rbind.fill()` from the `plyr` package](https://www.rdocumentation.org/packages/plyr/versions/1.8.4/topics/rbind.fill) and the package [data.table](https://cran.r-project.org/web/packages/data.table/index.html) that includes a `rbind()` method for `data.table` objects that handles such case (see [this answer on <i class="fa fa-stack-overflow" aria-hidden="true"></i>](https://stackoverflow.com/questions/18003717/efficient-way-to-rbind-data-frames-with-different-columns)). Those two options being mentioned, I would like to show how to do so with `dfTemplateMatch()` that is written in base R.

`dfTemplateMatch()` takes a data frame as the first argument (`x`) and the second argument (`y`) could either be another data frame or a vector of character strings. Based on this information  `dfTemplateMatch()` creates a data frame that has the same number of rows as `x` and
add columns for all names found in `y` that are not found in `x`. Moreover there is an argument `yonly` that allows the user to keep only names of `y` (when `yonly = TRUE`). Before calling `dfTemplateMatch()` I create two data frames :


```{r, results = "hold"}
df7 <- df6[1:5, 1:4]
df7
df8 <- df6[4:6]
df8
```

Now I use `dfTemplateMatch()` to create a third data frame based on two other:

```{r, results = "hold"}
dfTemplateMatch(df7, df8)
```

As expected, the output has 5 rows as `df6` and columns that are not in `df6` but in `df7` has been appended to `df6`. It is possible to use arguments `fill` and `col_classes` to custom the columns added.


```{r, results = "hold"}
dfTemplateMatch(df7, df8, fill = 1, col_classes = "numeric")
```

Note that another option is to `cbind()` another data frame created with `dfTemplate()` which is basically what `dfTemplateMatch()` does (but it also does the matching for you!). Based on this, I am now able to explain how to `rbind()` a specific subset of columns even though the names of the data frames do not match. In order to show how, I first create a list of data frames.


```{r}
lsdf <- apply(replicate(5, sample(nms, 6)), 2, dfTemplate, nrows = 5, fill = 1)
lsdf
```

My goal is to create a data frame that contains only the five first
columns, i.e. `r nms[1:5]`, the remaining columns must be discarded and
when a selected column is missing, it must be added (filled out with `NA`).
To do so, I simply need to call `dfTemplateMatch`:


```{r}
lsdf2 <- lapply(lsdf, dfTemplateMatch, nms[1:5], yonly = TRUE)
lsdf2
```

And now I can seamlessly `rdind()` the list `lsdf2`!

```{r}
do.call(rbind, lsdf2)
```

#### VoilÃ ! I hope you'll find this helpful! :boom:
