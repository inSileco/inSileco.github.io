---
title: Trick or tips 004 {R}
author: [kevin]
reviewer: [marieh]
date: 2019-08-13
tags: [R, tips, trickortips]
rpkgs: [base, utils, graphics, microbenchmark]
tweet: "Subset an array with a matrix and 4 more R tips"
estime: 6
output:
  rmarkdown::html_page:
    fig_width: 3
    dev: svg
---



<p>{{< trickortips >}}</p>
<div id="trick-or-tips-0004" class="section level2">
<h2><em>Trick or tips</em> 0004</h2>
<p>Today’s menu:</p>
<ol style="list-style-type: decimal">
<li>Subset an array with a matrix</li>
<li><code>nzchar()</code></li>
<li>Do you need to call <code>return()</code>?</li>
<li><code>invisible()</code></li>
<li><code>bquote()</code> and <code>substitute()</code></li>
</ol>
<p><br></p>
</div>
<div id="subset-an-array-with-a-matrix" class="section level2">
<h2>Subset an array with a matrix</h2>
<p>Let’s consider two arrays of letters: the first has two dimensions (i.e. a matrix) and the second one has 3.</p>
<pre class="r"><code>(arr2 &lt;- array(LETTERS[1:9], dim = c(3,3)))
#R&gt;       [,1] [,2] [,3]
#R&gt;  [1,] &quot;A&quot;  &quot;D&quot;  &quot;G&quot; 
#R&gt;  [2,] &quot;B&quot;  &quot;E&quot;  &quot;H&quot; 
#R&gt;  [3,] &quot;C&quot;  &quot;F&quot;  &quot;I&quot;
class(arr2)
#R&gt;  [1] &quot;matrix&quot; &quot;array&quot;
(arr3 &lt;- array(LETTERS[1:18], dim = c(3, 3, 2)))
#R&gt;  , , 1
#R&gt;  
#R&gt;       [,1] [,2] [,3]
#R&gt;  [1,] &quot;A&quot;  &quot;D&quot;  &quot;G&quot; 
#R&gt;  [2,] &quot;B&quot;  &quot;E&quot;  &quot;H&quot; 
#R&gt;  [3,] &quot;C&quot;  &quot;F&quot;  &quot;I&quot; 
#R&gt;  
#R&gt;  , , 2
#R&gt;  
#R&gt;       [,1] [,2] [,3]
#R&gt;  [1,] &quot;J&quot;  &quot;M&quot;  &quot;P&quot; 
#R&gt;  [2,] &quot;K&quot;  &quot;N&quot;  &quot;Q&quot; 
#R&gt;  [3,] &quot;L&quot;  &quot;O&quot;  &quot;R&quot;
class(arr3)
#R&gt;  [1] &quot;array&quot;</code></pre>
<p>Let’s say, you need to subset a specific set of values based on the position of the elements. To subset a single element, say <code>"G"</code>, there are a couple of options, but I guess the most common approach is to use <code>[</code> with one value per dimension:</p>
<pre class="r"><code>arr2[1,3]
#R&gt;  [1] &quot;G&quot;
arr3[1,3,1]
#R&gt;  [1] &quot;G&quot;</code></pre>
<p>or with a single value giving the position of the element:</p>
<pre class="r"><code>arr2[7]
#R&gt;  [1] &quot;G&quot;
arr3[7]
#R&gt;  [1] &quot;G&quot;</code></pre>
<p>Now we consider the case where you have a vector of positions (one value per dimension of the array), in this case, beware the orientation of the vector!</p>
<pre class="r"><code># with the line below, we get the 1rst and 3rd elements because we&#39;re using a column vector
arr2[c(1,3)]
#R&gt;  [1] &quot;A&quot; &quot;C&quot;
# whereas with a row vector, we obtain the element of the 1rst row and the 3rd column
arr2[t(c(1,3))]
#R&gt;  [1] &quot;G&quot;</code></pre>
<p>And for more than one element, you need to use a matrix with one row per element to be subset:</p>
<pre class="r"><code>(mat &lt;- rbind(c(1,3), c(2,2)))
#R&gt;       [,1] [,2]
#R&gt;  [1,]    1    3
#R&gt;  [2,]    2    2
arr2[mat]
#R&gt;  [1] &quot;G&quot; &quot;E&quot;</code></pre>
<p>Similarly, with an array of 3 dimensions, the matrix will have three columns and as many row as there are elements:</p>
<pre class="r"><code># Let us subset `E`,`C` and `O` and `C` (again)
(msub &lt;- rbind(c(2,2,1), c(3, 1, 1), c(3, 2, 2), c(3, 1, 1)))
#R&gt;       [,1] [,2] [,3]
#R&gt;  [1,]    2    2    1
#R&gt;  [2,]    3    1    1
#R&gt;  [3,]    3    2    2
#R&gt;  [4,]    3    1    1
arr3[msub]
#R&gt;  [1] &quot;E&quot; &quot;C&quot; &quot;O&quot; &quot;C&quot;</code></pre>
<p>Two additional comments. First, we should always keep in mind that data frames and arrays are different:</p>
<pre class="r"><code># this gives you the 1rst and 3rd **entire columns**
as.data.frame(arr2)[c(1,3)]
#R&gt;    V1 V3
#R&gt;  1  A  G
#R&gt;  2  B  H
#R&gt;  3  C  I
# this still gives you the element on the 1rst row and the 3rd column
as.data.frame(arr2)[t(c(1,3))]
#R&gt;  [1] &quot;G&quot;</code></pre>
<p>Second, if you are a <a href="https://www.tidyverse.org/">tidyverse</a> user, there is a new article dealing with <a href="https://tibble.tidyverse.org/dev/articles/subassign.html#section">subassigment with tibble</a> :sunglasses:.</p>
</div>
<div id="nzchar" class="section level2">
<h2><code>nzchar()</code></h2>
<p>You may already be aware of <code>nchar()</code>, a function that returns the number of characters of a given character vector:</p>
<pre class="r"><code>nchar(c(&quot;insil&quot;, &quot;eco&quot;, &quot;&quot;))
#R&gt;  [1] 5 3 0</code></pre>
<p><code>nzchar()</code> returns <code>TRUE</code> for every character string in the vector that has at least 1 character:</p>
<pre class="r"><code>vec &lt;- c(&quot;insil&quot;, &quot;eco&quot;, &quot;&quot;)
nzchar(vec)
#R&gt;  [1]  TRUE  TRUE FALSE
# is there any empty character string in `vec`?
any(nzchar(vec))
#R&gt;  [1] TRUE</code></pre>
<p>Interesting, but let’s dig deeper: I can think about no less than 3 ways of writing a equivalent function with one more character:</p>
<pre class="r"><code>nchar(vec) &gt; 0
#R&gt;  [1]  TRUE  TRUE FALSE
!! nchar(vec)
#R&gt;  [1]  TRUE  TRUE FALSE
nchar(vec) &amp; 1
#R&gt;  [1]  TRUE  TRUE FALSE</code></pre>
<p>One more character… so why bother? :bulb: It should be a matter of performance! Let’s check that out with the cool :package: <a href="https://cran.r-project.org/web/packages/microbenchmark/index.html">microbenchmark</a>:</p>
<pre class="r"><code>library(microbenchmark)
microbenchmark(nchar(vec) &gt; 0, !! nchar(vec), nchar(vec) &amp; 1, nzchar(vec),
  times = 1000L)
#R&gt;  Unit: nanoseconds
#R&gt;             expr min  lq     mean median   uq   max neval cld
#R&gt;   nchar(vec) &gt; 0 779 824 1391.011  862.5 1021 22448  1000   b
#R&gt;     !!nchar(vec) 850 892 1589.893  935.0 1082 30404  1000   b
#R&gt;   nchar(vec) &amp; 1 868 917 1405.321  969.5 1115 31161  1000   b
#R&gt;      nzchar(vec)  79 100  202.783  105.0  113 20899  1000  a</code></pre>
<p>Yep yep!<code>nzchar()</code> is indeed way faster :rocket:!</p>
</div>
<div id="do-you-need-to-use-return" class="section level2">
<h2>Do you need to use <code>return()</code>?</h2>
<p>If you have already written your own function, you must have used <code>return()</code>
to specify what your function should return. There are programming languages where this instruction is mandatory, not in R! Check out the documentation <code>?return</code>:</p>
<blockquote>
<p>If the end of a function is reached without calling ‘return’, the
value of the last evaluated expression is returned.</p>
</blockquote>
<p>Let me write 2 functions:</p>
<pre class="r"><code>add_v &lt;- function(x, y) {
   x + y
}
add_v2 &lt;- function(x, y) {
   return(x + y)
}</code></pre>
<p><code>add_v()</code> and <code>add_v2()</code> are equivalent! So… do we care? Well, you must bear in mind that whenever <code>return()</code> is encountered, the evaluation of the set of expressions within the function is stopped and therefore some time can be saved:</p>
<pre class="r"><code>foo &lt;- function(x) {
    out &lt;- 0
    if (x &gt; 3) out &lt;- 3
    if (x &gt; 2) out &lt;- 2
    if (x &gt; 1) out &lt;- 1
    return(out)
}
foo2 &lt;- function(x) {
  out &lt;- 0
  if (x &gt; 3) return(3)
  if (x &gt; 2) return(2)
  if (x &gt; 1) return(1)
  return(out)
}
microbenchmark(foo(4), foo2(4), times = 1e5)
#R&gt;  Unit: nanoseconds
#R&gt;      expr min  lq     mean median  uq      max neval cld
#R&gt;    foo(4) 397 434 628.3395    448 466  4726805 1e+05   a
#R&gt;   foo2(4) 267 291 527.4016    301 312 14848361 1e+05   a</code></pre>
</div>
<div id="invisible" class="section level2">
<h2><code>invisible()</code></h2>
<p>Let’s keep talking about what functions return. The function <code>invisible()</code> allows you to return an invisible copy of an object, meaning that nothing is (apparently) return if not assigned:</p>
<pre class="r"><code>add_v &lt;- function(x, y) {
  x + y
}
##
add_i &lt;- function(x, y) {
  invisible(x + y)
}
add_v(2, 3)
#R&gt;  [1] 5
add_i(2, 3)
res &lt;- add_i(2, 3)
res
#R&gt;  [1] 5</code></pre>
<p>But… why? As explained in the documentation (<code>?invisible</code>):</p>
<blockquote>
<p>This function can be useful when it is desired to have functions
return values which can be assigned, but which do not print when
they are not assigned.</p>
</blockquote>
<p>This is indeed helpful when you have a function that creates a plot (and you don’t normally to assign the result) for which you sometimes need to use an object that was created during the evaluation of the function:</p>
<pre class="r"><code>plot_logy &lt;- function(x, y) {
  # create ty
  ty &lt;- log10(y + 1)
  plot(x, ty)
  invisible(ty)
}
plot_logy(0:10, 0:10)</code></pre>
<p><img src="/post/2019/trick_or_tips004_files/figure-html/unnamed-chunk-11-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code># get ty
ty &lt;- plot_logy(0:10, 0:10)</code></pre>
<p><img src="/post/2019/trick_or_tips004_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;" /></p>
<pre class="r"><code>ty
#R&gt;   [1] 0.0000000 0.3010300 0.4771213 0.6020600 0.6989700 0.7781513 0.8450980
#R&gt;   [8] 0.9030900 0.9542425 1.0000000 1.0413927</code></pre>
</div>
<div id="bquote-and-substitute" class="section level2">
<h2><code>bquote()</code> and <code>substitute()</code></h2>
<p>When using mathematical annotations, we sometimes need to include the value
of a variable. In such case, <code>bquote()</code> or <code>substitute()</code> are the functions you
would need (rather than <code>expression()</code> you may already be familiar with).</p>
<p>If you opt for <code>bquote()</code>, then variables to be evaluated must be put in
brackets and preceded by a dot, e.g. <code>.(var)</code>. If you choose <code>substitute()</code>,
then variables evaluated will be the ones included in the list passed as
argument <code>env</code> (which can also be the name of a environment).</p>
<p>Let’s use both functions in to add mathematical expressions in an empty plot:</p>
<pre class="r"><code>delta &lt;- 1.5
plot(c(0,1), c(0,1), type = &quot;n&quot;, axes = FALSE, ann = FALSE)
text(0.5, .75, labels = bquote(beta^j == .(delta) + bold(&quot;h&quot;)), cex = 3)
text(0.5, .25, labels = substitute(alpha[i] == a + delta, env = list(a = 2)), cex = 3)
box()</code></pre>
<p><img src="/post/2019/trick_or_tips004_files/figure-html/bquote-1.png" width="768" style="display: block; margin: auto;" /></p>
<pre class="r"><code>print(path_root)
#R&gt;  [1] &quot;/home/kc/git/inSilecoBlog/inSileco.github.io&quot;</code></pre>
<div id="thats-all-folks" class="section level4">
<h4><strong>That’s all folks!</strong></h4>
<div style="padding: 2rem 0rem 2rem 0rem;">
<details>
<summary>
<h4>
<i class="fa fa-chevron-right" aria-hidden="true"></i>Session info
<i class="fa fa-cogs" aria-hidden="true"></i>
</h4>
<p></summary></p>
<pre class="r"><code>sessionInfo()
#R&gt;  R version 4.2.0 (2022-04-22)
#R&gt;  Platform: x86_64-pc-linux-gnu (64-bit)
#R&gt;  Running under: Debian GNU/Linux bookworm/sid
#R&gt;  
#R&gt;  Matrix products: default
#R&gt;  BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.1
#R&gt;  LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.1
#R&gt;  
#R&gt;  locale:
#R&gt;   [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              
#R&gt;   [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    
#R&gt;   [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   
#R&gt;   [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 
#R&gt;   [9] LC_ADDRESS=C               LC_TELEPHONE=C            
#R&gt;  [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       
#R&gt;  
#R&gt;  attached base packages:
#R&gt;  [1] stats     graphics  grDevices utils     datasets  methods   base     
#R&gt;  
#R&gt;  other attached packages:
#R&gt;  [1] microbenchmark_1.4.9   inSilecoRef_0.0.1.9000
#R&gt;  
#R&gt;  loaded via a namespace (and not attached):
#R&gt;   [1] Rcpp_1.0.8.3      mvtnorm_1.1-3     lattice_0.20-45   lubridate_1.8.0  
#R&gt;   [5] zoo_1.8-10        ps_1.7.0          assertthat_0.2.1  digest_0.6.29    
#R&gt;   [9] utf8_1.2.2        mime_0.12         R6_2.5.1          plyr_1.8.7       
#R&gt;  [13] backports_1.4.1   evaluate_0.15     highr_0.9         httr_1.4.3       
#R&gt;  [17] blogdown_1.10     pillar_1.7.0      rlang_1.0.2       multcomp_1.4-19  
#R&gt;  [21] curl_4.3.2        data.table_1.14.2 miniUI_0.1.1.1    callr_3.7.0      
#R&gt;  [25] jquerylib_0.1.4   Matrix_1.4-1      DT_0.23           rmarkdown_2.14   
#R&gt;  [29] splines_4.2.0     RefManageR_1.3.0  rcrossref_1.1.0   stringr_1.4.0    
#R&gt;  [33] htmlwidgets_1.5.4 igraph_1.2.11     shiny_1.7.1       compiler_4.2.0   
#R&gt;  [37] httpuv_1.6.5      xfun_0.31         pkgconfig_2.0.3   htmltools_0.5.2  
#R&gt;  [41] tidyselect_1.1.2  tibble_3.1.7      httpcode_0.3.0    bookdown_0.26    
#R&gt;  [45] codetools_0.2-18  fansi_1.0.3       crayon_1.5.1      dplyr_1.0.9      
#R&gt;  [49] withr_2.5.0       later_1.3.0       MASS_7.3-57       grid_4.2.0       
#R&gt;  [53] crul_1.2.0        jsonlite_1.8.0    xtable_1.8-4      lifecycle_1.0.1  
#R&gt;  [57] DBI_1.1.2         magrittr_2.0.3    cli_3.3.0         stringi_1.7.6    
#R&gt;  [61] promises_1.2.0.1  xml2_1.3.3        bslib_0.3.1       ellipsis_0.3.2   
#R&gt;  [65] targets_0.12.0    generics_0.1.2    vctrs_0.4.1       sandwich_3.0-1   
#R&gt;  [69] TH.data_1.1-1     tools_4.2.0       glue_1.6.2        purrr_0.3.4      
#R&gt;  [73] survival_3.3-1    processx_3.5.3    fastmap_1.1.0     yaml_2.3.5       
#R&gt;  [77] base64url_1.4     knitr_1.39        sass_0.4.1</code></pre>
</details>
</div>
</div>
</div>
